\newpage

## 10. **Interrupts and Exception Handling**

Interrupts and exceptions are crucial aspects of the ARM architecture that allow the processor to respond promptly to events and errors, ensuring efficient and robust system operation. This chapter delves into the interrupt mechanism, explaining how ARM processors manage and prioritize interrupts to maintain smooth functionality. Readers will learn to write Interrupt Service Routines (ISRs) to handle both hardware and software interrupts effectively. The chapter also covers exception handling, providing strategies to deal with unexpected events and errors, thereby enhancing the resilience of the code. A comprehensive example will be presented to illustrate the practical implementation of these concepts, tying together theory and practice for a thorough understanding.

### Interrupt Mechanism: How Interrupts Work on ARM Processors

#### Introduction

Interrupts are a critical feature in ARM processors that allow for the efficient handling of asynchronous events. These events can be triggered by both hardware and software, enabling the processor to respond to immediate needs without the overhead of constant polling. Understanding the interrupt mechanism in ARM processors is essential for developing responsive and efficient embedded systems.

#### Basic Concepts

##### What is an Interrupt?

An interrupt is a signal that temporarily halts the normal execution flow of a processor to attend to a specific event or condition. Upon receiving an interrupt, the processor saves its current state and executes a special routine called an Interrupt Service Routine (ISR) to address the event. After the ISR is executed, the processor restores its previous state and resumes normal execution.

##### Types of Interrupts

1. **Hardware Interrupts**: These are generated by external devices such as timers, keyboards, or network interfaces. They signal the processor to handle events like input/output operations, hardware malfunctions, or real-time clock ticks.

2. **Software Interrupts**: These are generated by software instructions, usually to request system services or handle exceptional conditions. They are often used for system calls or to implement multitasking.

#### ARM Processor Interrupt Architecture

ARM processors utilize a sophisticated interrupt architecture designed to handle multiple interrupts with minimal latency. The key components of this architecture include:

1. **Vectored Interrupt Controller (VIC)**: The VIC manages multiple interrupt sources, prioritizes them, and provides the appropriate vector address for the ISR. It ensures that the highest-priority interrupt is serviced first.

2. **Generic Interrupt Controller (GIC)**: Found in more advanced ARM processors, the GIC handles interrupts in a multi-core environment, allowing for efficient distribution and management of interrupts across multiple cores.

3. **Interrupt Vector Table (IVT)**: The IVT is a table that holds the addresses of the ISRs for different interrupt sources. When an interrupt occurs, the processor uses the IVT to quickly jump to the appropriate ISR.

#### Interrupt Handling Process

The process of handling an interrupt in an ARM processor can be broken down into several steps:

1. **Interrupt Generation**: An interrupt is generated by an external device or software instruction.

2. **Interrupt Acknowledgment**: The VIC or GIC acknowledges the interrupt and determines its priority.

3. **Processor State Saving**: The current state of the processor, including the program counter (PC) and relevant registers, is saved to ensure that execution can resume correctly after the ISR.

4. **Vector Address Lookup**: The interrupt vector table is consulted to find the address of the ISR corresponding to the interrupt.

5. **ISR Execution**: The processor jumps to the ISR address and executes the routine to handle the interrupt.

6. **Interrupt Clearing**: The interrupt source is cleared to prevent repeated handling of the same interrupt.

7. **Processor State Restoration**: The saved processor state is restored, and normal execution resumes from where it was interrupted.

#### ARM Exception Levels

ARM processors support multiple exception levels to manage interrupts and exceptions:

1. **EL0 (User Mode)**: Normal application execution.

2. **EL1 (Kernel Mode)**: Operating system kernel execution, handling system calls, and managing hardware.

3. **EL2 (Hypervisor Mode)**: Used for virtualization to manage guest operating systems.

4. **EL3 (Secure Monitor Mode)**: Handles secure world operations, often used in TrustZone technology for secure execution.

#### Interrupt Prioritization and Nesting

Interrupt prioritization ensures that higher-priority interrupts are serviced before lower-priority ones. ARM processors achieve this through the following mechanisms:

1. **Priority Levels**: Each interrupt source is assigned a priority level. The VIC or GIC ensures that higher-priority interrupts preempt lower-priority ones.

2. **Interrupt Nesting**: Interrupts can be nested, meaning that a higher-priority interrupt can interrupt an ISR that is currently executing. This requires careful management of the processor state to ensure that each ISR can complete its task without data corruption or loss of context.

#### Configuring Interrupts on ARM

Configuring interrupts on ARM processors involves several steps:

1. **Interrupt Source Configuration**: External devices or software must be configured to generate interrupts. This often involves setting up control registers in the device to enable interrupt generation.

2. **Interrupt Vector Table Setup**: The IVT must be populated with the addresses of the ISRs. This is typically done during system initialization.

3. **Interrupt Controller Configuration**: The VIC or GIC must be configured to handle the specific interrupts, including setting priority levels and enabling the interrupts.

4. **Enabling Interrupts**: The global interrupt enable bit in the processor's status register must be set to allow interrupts to be processed.

#### Writing Interrupt Service Routines

ISRs are special functions that are designed to handle interrupts. Writing efficient and effective ISRs involves several considerations:

1. **Minimize Latency**: ISRs should be as short and fast as possible to minimize the time the processor spends in the interrupt state. Long ISRs can lead to missed interrupts and degraded system performance.

2. **State Preservation**: ISRs must save and restore the processor state to ensure that normal execution can resume correctly. This includes saving and restoring registers and other critical state information.

3. **Reentrancy**: ISRs should be reentrant, meaning they can safely be interrupted and called again. This is particularly important in systems with nested interrupts.

4. **Avoid Blocking Operations**: ISRs should avoid operations that can block execution, such as waiting for I/O operations to complete. Such operations can significantly increase ISR latency.

#### Exception Handling in ARM

Exception handling is closely related to interrupt handling but is used to manage unexpected or exceptional conditions. ARM processors use a similar mechanism for handling exceptions, including the use of an exception vector table and dedicated exception levels.

1. **Synchronous Exceptions**: These occur as a direct result of program execution, such as illegal instructions or memory access violations.

2. **Asynchronous Exceptions**: These are similar to hardware interrupts and occur independently of program execution, such as system errors or external signals.

#### Combined Example: Handling a Timer Interrupt

To illustrate the interrupt mechanism in ARM processors, let's consider an example where a timer interrupt is used to toggle an LED:

1. **Timer Configuration**: Configure the timer to generate an interrupt at a specific interval.

```assembly
LDR R0, =TIMER_BASE       ; Load the base address of the timer
LDR R1, =TIMER_INTERVAL   ; Load the desired interval
STR R1, [R0, #TIMER_LOAD] ; Set the timer interval
MOV R1, #1
STR R1, [R0, #TIMER_CTRL] ; Enable the timer and its interrupt
```

2. **Interrupt Vector Table Setup**: Populate the IVT with the address of the ISR.

```assembly
LDR R0, =IVT_BASE          ; Load the base address of the IVT
LDR R1, =timer_isr         ; Load the address of the timer ISR
STR R1, [R0, #TIMER_VECTOR]; Set the ISR address in the IVT
```

3. **Interrupt Service Routine**: Write the ISR to handle the timer interrupt.

```assembly
timer_isr:
    PUSH {R0-R1}            ; Save registers
    LDR R0, =LED_BASE       ; Load the base address of the LED
    LDR R1, [R0]            ; Read the current LED state
    EOR R1, R1, #1          ; Toggle the LED state
    STR R1, [R0]            ; Write the new LED state
    LDR R0, =TIMER_BASE     ; Load the base address of the timer
    MOV R1, #1
    STR R1, [R0, #TIMER_CLR]; Clear the timer interrupt
    POP {R0-R1}             ; Restore registers
    SUBS PC, LR, #4         ; Return from interrupt
```

### Writing Interrupt Service Routines (ISR): Handling Hardware and Software Interrupts

#### Introduction

Interrupt Service Routines (ISRs) are specialized functions designed to handle interrupts, allowing the processor to manage both hardware and software events efficiently. Writing ISRs is a critical skill for embedded system developers, as it ensures that systems can respond promptly to various events without the need for constant polling. This chapter provides an in-depth exploration of ISRs, detailing their design, implementation, and best practices for handling hardware and software interrupts.

#### Fundamentals of Interrupt Service Routines

##### Definition and Purpose of ISRs

An Interrupt Service Routine (ISR) is a function that executes in response to an interrupt. Its primary purpose is to handle the interrupt event, perform necessary actions, and then return control to the main program. ISRs enable the processor to address urgent tasks while minimizing disruption to the normal execution flow.

##### Hardware Interrupts vs. Software Interrupts

1. **Hardware Interrupts**: Generated by external devices, such as timers, keyboards, or sensors, hardware interrupts require immediate attention from the processor. Examples include a timer reaching zero, a key press, or an incoming data packet.

2. **Software Interrupts**: Initiated by software instructions, software interrupts often request system services or handle exceptional conditions. Examples include system calls, exceptions, or deliberate breakpoints for debugging.

#### Anatomy of an ISR

ISRs must be carefully crafted to ensure they are efficient, responsive, and safe. The typical structure of an ISR includes:

1. **Prologue**: This section saves the processor state, including registers and the program counter (PC), to ensure the main program can resume correctly after the ISR completes.

2. **Interrupt Handling**: The core logic of the ISR, where the specific actions to handle the interrupt are performed. This can include reading or writing data, toggling hardware states, or signaling other parts of the system.

3. **Epilogue**: This section restores the saved processor state and clears the interrupt flag to prevent the same interrupt from being handled repeatedly.

#### Writing Efficient ISRs

##### Minimizing Latency

Latency is the time taken from when an interrupt occurs to when the ISR starts executing. Minimizing latency is crucial to ensure that interrupts are handled promptly. Strategies to reduce latency include:

1. **Using Fast Interrupt Requests (FIQs)**: ARM processors support FIQs, which have higher priority and lower latency than standard interrupts (IRQs). FIQs are suitable for time-critical tasks.

2. **Optimizing Context Switching**: Efficiently saving and restoring the processor state can significantly reduce ISR latency. Using dedicated registers or minimizing the number of saved registers can help.

3. **Interrupt Vector Table (IVT) Optimization**: Ensuring the IVT is in fast, accessible memory can reduce the time taken to look up the ISR address.

##### Reducing ISR Execution Time

ISRs should execute as quickly as possible to minimize the time the processor spends handling interrupts. Techniques to achieve this include:

1. **Keeping ISRs Short**: ISRs should perform only the essential actions needed to handle the interrupt. Any non-critical processing should be deferred to the main program or a lower-priority task.

2. **Avoiding Blocking Operations**: ISRs should not include operations that can block execution, such as waiting for I/O operations to complete. Instead, they should use non-blocking methods or set flags for the main program to handle.

3. **Using Inline Assembly**: For time-critical sections of the ISR, using inline assembly can provide finer control over the execution and optimize performance.

##### Ensuring Safe Execution

ISRs must be reentrant and thread-safe to handle multiple interrupts without causing data corruption or system instability. Practices to ensure safe ISR execution include:

1. **Atomic Operations**: Use atomic operations to modify shared data structures, ensuring that the operations are completed without interruption.

2. **Disabling Nested Interrupts**: In some cases, it may be necessary to temporarily disable nested interrupts to prevent reentrancy issues. However, this should be done sparingly to avoid missing critical interrupts.

3. **Using Volatile Variables**: Variables accessed within ISRs should be declared as volatile to prevent the compiler from optimizing away critical reads and writes.

#### Example: Writing a Hardware ISR

Consider an example where an ISR handles a timer interrupt to toggle an LED. The following steps illustrate the process of writing this ISR:

1. **Timer Configuration**: Configure the timer to generate an interrupt at a specific interval.

```assembly
LDR R0, =TIMER_BASE       ; Load the base address of the timer
LDR R1, =TIMER_INTERVAL   ; Load the desired interval
STR R1, [R0, #TIMER_LOAD] ; Set the timer interval
MOV R1, #1
STR R1, [R0, #TIMER_CTRL] ; Enable the timer and its interrupt
```

2. **Interrupt Vector Table Setup**: Populate the IVT with the address of the ISR.

```assembly
LDR R0, =IVT_BASE          ; Load the base address of the IVT
LDR R1, =timer_isr         ; Load the address of the timer ISR
STR R1, [R0, #TIMER_VECTOR]; Set the ISR address in the IVT
```

3. **Interrupt Service Routine**: Write the ISR to handle the timer interrupt.

```assembly
timer_isr:
    PUSH {R0-R1}            ; Save registers
    LDR R0, =LED_BASE       ; Load the base address of the LED
    LDR R1, [R0]            ; Read the current LED state
    EOR R1, R1, #1          ; Toggle the LED state
    STR R1, [R0]            ; Write the new LED state
    LDR R0, =TIMER_BASE     ; Load the base address of the timer
    MOV R1, #1
    STR R1, [R0, #TIMER_CLR]; Clear the timer interrupt
    POP {R0-R1}             ; Restore registers
    SUBS PC, LR, #4         ; Return from interrupt
```

#### Example: Writing a Software ISR

Software interrupts can be used for system calls or handling exceptions. Consider an example where a software interrupt is used to handle a system call for printing a string to a console:

1. **Software Interrupt Instruction**: Generate a software interrupt using the `SWI` instruction.

```assembly
MOV R0, #SYSCALL_PRINT    ; Load the system call number for printing
LDR R1, =message          ; Load the address of the message
SWI #0                    ; Generate the software interrupt
```

2. **Interrupt Vector Table Setup**: Populate the IVT with the address of the software ISR.

```assembly
LDR R0, =IVT_BASE           ; Load the base address of the IVT
LDR R1, =swi_isr            ; Load the address of the software ISR
STR R1, [R0, #SWI_VECTOR]   ; Set the ISR address in the IVT
```

3. **Interrupt Service Routine**: Write the ISR to handle the software interrupt.

```assembly
swi_isr:
    PUSH {R0-R3, LR}         ; Save registers and link register
    LDR R0, [SP, #16]        ; Load the system call number from the stack
    CMP R0, #SYSCALL_PRINT   ; Check if the system call is for printing
    BNE unknown_syscall      ; Branch if not a print syscall
    LDR R1, [SP, #20]        ; Load the address of the message
    BL print_string          ; Call the print string function
    B swi_return             ; Branch to return

unknown_syscall:
    ; Handle unknown syscall
    B swi_return             ; Branch to return

swi_return:
    POP {R0-R3, PC}          ; Restore registers and return
```

#### Advanced ISR Techniques

##### Nested Interrupts

In systems with multiple interrupt sources, it may be necessary to handle nested interrupts. This involves allowing higher-priority interrupts to preempt lower-priority ones. Careful management of the processor state is required to ensure that nested interrupts do not corrupt data or lead to unpredictable behavior.

```assembly
nested_isr:
    CPSID I                  ; Disable interrupts
    PUSH {R0-R3, LR}         ; Save registers and link register
    CPSIE I                  ; Enable interrupts

    ; Handle the interrupt
    LDR R0, =INTERRUPT_SOURCE; Load the interrupt source
    BL handle_interrupt      ; Call the interrupt handler

    CPSID I                  ; Disable interrupts
    POP {R0-R3, PC}          ; Restore registers and return
```

##### Deferred Interrupt Handling

In some cases, it may be beneficial to defer non-critical interrupt processing to a later time. This can be achieved using a deferred procedure call (DPC) or a similar mechanism. The ISR performs minimal processing and schedules the deferred work to be handled by a lower-priority task.

```assembly
deferred_isr:
    PUSH {R0-R3, LR}          ; Save registers and link register

    ; Perform minimal processing
    LDR R0, =DEFERRED_QUEUE   ; Load the deferred queue
    LDR R1, =work_item        ; Load the work item
    STR R1, [R0]              ; Enqueue the work item

    POP {R0-R3, PC}           ; Restore registers and return

deferred_worker:
    ; Handle deferred work items
    LDR R0, =DEFERRED_QUEUE   ; Load the deferred queue
    LDR R1, [R0]              ; Dequeue a work item
    ; Process the work item
    B deferred_worker         ; Loop to handle next item
```

### Exception Handling: Dealing with Exceptions and Ensuring Robust Code

#### Introduction

Exception handling is a critical aspect of programming on ARM processors, allowing developers to manage and respond to unexpected events or errors that occur during program execution. Properly handling exceptions ensures that systems remain robust and reliable, even in the face of unforeseen issues. This chapter provides a comprehensive exploration of exception handling in ARM architecture, detailing the types of exceptions, their handling mechanisms, and best practices for ensuring robust code.

#### Fundamentals of Exceptions

##### Definition and Purpose

An exception is an event that disrupts the normal flow of program execution, typically indicating an error or unusual condition that requires special processing. Unlike interrupts, which are usually generated by external hardware or software requests, exceptions are often the result of the processor's internal operations, such as executing illegal instructions or accessing invalid memory.

##### Types of Exceptions in ARM

ARM processors support several types of exceptions, each serving a different purpose:

1. **Reset**: Occurs when the processor is reset, either due to power-on, software request, or external reset signal. This is the highest priority exception and initiates system startup.

2. **Undefined Instruction**: Triggered when the processor encounters an instruction that it does not recognize or is not supported in the current execution mode.

3. **Software Interrupt (SWI)**: Generated by executing the SWI instruction, typically used to invoke system calls or other predefined software functions.

4. **Prefetch Abort**: Occurs when the processor attempts to fetch an instruction from an invalid memory address.

5. **Data Abort**: Triggered when an invalid memory access occurs during data read or write operations.

6. **IRQ (Interrupt Request)**: A standard hardware interrupt, used to handle external events.

7. **FIQ (Fast Interrupt Request)**: A high-priority hardware interrupt, used for time-critical events requiring minimal latency.

#### ARM Exception Handling Mechanism

##### Exception Vectors

ARM processors use an exception vector table to handle exceptions. This table contains the addresses of the exception handlers and is located at a fixed memory address, typically starting at 0x00000000 or 0xFFFF0000, depending on the processor mode and configuration. Each entry in the table corresponds to a specific exception type.

Example of an exception vector table setup:

```assembly
    AREA    VECTORS, CODE, READONLY
    ENTRY

    LDR     PC, Reset_Handler
    LDR     PC, Undefined_Handler
    LDR     PC, SWI_Handler
    LDR     PC, Prefetch_Abort_Handler
    LDR     PC, Data_Abort_Handler
    NOP                         ; Reserved
    LDR     PC, IRQ_Handler
    LDR     PC, FIQ_Handler

Reset_Handler      DCD Reset_Handler_Address
Undefined_Handler  DCD Undefined_Handler_Address
SWI_Handler        DCD SWI_Handler_Address
Prefetch_Abort_Handler DCD Prefetch_Abort_Handler_Address
Data_Abort_Handler DCD Data_Abort_Handler_Address
IRQ_Handler        DCD IRQ_Handler_Address
FIQ_Handler        DCD FIQ_Handler_Address
```

##### Handling Exceptions

When an exception occurs, the processor performs several steps to ensure the exception is handled correctly and that normal execution can resume afterwards:

1. **Save Processor State**: The processor saves the current state, including the program counter (PC) and status registers (CPSR), to ensure that execution can resume correctly after the exception is handled.

2. **Switch to Exception Mode**: The processor switches to an appropriate exception mode (e.g., Supervisor mode, IRQ mode) and uses a dedicated stack for that mode.

3. **Load Exception Vector**: The processor loads the address of the exception handler from the exception vector table and jumps to it.

4. **Execute Exception Handler**: The exception handler executes, performing the necessary actions to address the exception (e.g., handling the error, performing a recovery operation).

5. **Restore Processor State**: The processor restores the saved state and returns to the previous mode, resuming normal execution.

##### Example: Handling a Data Abort Exception

Consider an example where a data abort exception occurs due to an invalid memory access:

1. **Data Abort Handler Setup**: Define the data abort handler in the exception vector table.

```assembly
    LDR     PC, Data_Abort_Handler
Data_Abort_Handler_Address DCD Data_Abort_Handler
```

2. **Data Abort Handler Implementation**: Write the handler to manage the exception.

```assembly
Data_Abort_Handler:
    SUB     LR, LR, #8             ; Adjust return address
    STMFD   SP!, {R0-R12, LR}      ; Save registers
    MRS     R0, SPSR               ; Save SPSR
    STMFD   SP!, {R0}
    
    ; Handle the exception (e.g., log the error, attempt recovery)
    
    LDMFD   SP!, {R0}              ; Restore SPSR
    MSR     SPSR_cxsf, R0
    LDMFD   SP!, {R0-R12, PC}^     ; Restore registers and return
```

#### Exception Modes and Stacks

ARM processors have several exception modes, each with its own stack pointer and set of banked registers. These modes include:

1. **Supervisor Mode (SVC)**: Entered on reset and SWI exceptions, used for general exception handling and system calls.
2. **IRQ Mode**: Used for standard interrupt handling.
3. **FIQ Mode**: Used for fast interrupt handling, with additional banked registers to reduce context switching time.
4. **Abort Mode**: Used for handling prefetch and data abort exceptions.
5. **Undefined Mode**: Used for handling undefined instruction exceptions.
6. **System Mode**: Privileged mode, similar to user mode but with access to system resources.

Each mode has a dedicated stack to prevent exceptions from corrupting the stack used by normal program execution. The stack setup for each mode is typically done during system initialization.

```assembly
    LDR     SP, =SVC_Stack       ; Set up Supervisor stack
    LDR     SP, =IRQ_Stack       ; Set up IRQ stack
    LDR     SP, =FIQ_Stack       ; Set up FIQ stack
    LDR     SP, =ABT_Stack       ; Set up Abort stack
    LDR     SP, =UND_Stack       ; Set up Undefined stack
    LDR     SP, =SYS_Stack       ; Set up System stack
```

#### Best Practices for Exception Handling

##### Graceful Degradation

Ensure that the system can continue to operate in a degraded mode if a critical exception occurs. This involves providing fallback mechanisms and ensuring that essential functions remain operational.

##### Logging and Diagnostics

Implement comprehensive logging to record exception details, including the type of exception, the address at which it occurred, and the processor state at the time. This information is invaluable for diagnosing and fixing issues.

```assembly
Exception_Handler:
    STMFD   SP!, {R0-R12, LR}      ; Save registers
    MRS     R0, SPSR               ; Save SPSR
    STMFD   SP!, {R0}

    ; Log exception details
    LDR     R0, =Exception_Log
    STR     LR, [R0, #0]           ; Log return address
    STR     SPSR, [R0, #4]         ; Log SPSR

    ; Perform additional diagnostics or recovery actions

    LDMFD   SP!, {R0}              ; Restore SPSR
    MSR     SPSR_cxsf, R0
    LDMFD   SP!, {R0-R12, PC}^     ; Restore registers and return
```

##### Robust Code Design

Design code to anticipate and handle potential exceptions gracefully. This includes:

1. **Validating Inputs**: Check all inputs for validity before using them.
2. **Using Safe Memory Accesses**: Avoid accessing memory locations that may not be valid or initialized.
3. **Implementing Watchdogs**: Use watchdog timers to recover from unexpected hangs or infinite loops.

##### Testing and Verification

Thoroughly test exception handling code under various conditions to ensure it performs correctly. This includes:

1. **Simulating Exceptions**: Use tools or specific test cases to simulate exceptions and verify the handling routines.
2. **Stress Testing**: Subject the system to stress conditions to ensure it can handle multiple exceptions gracefully.
3. **Code Review and Analysis**: Conduct code reviews and static analysis to identify potential exception handling issues.

#### Advanced Exception Handling Techniques

##### Nested Exceptions

Handling nested exceptions requires careful management of the processor state. ARM processors support nested exceptions by saving the state of the first exception and allowing a second exception to be handled. Properly nesting exceptions ensures that critical errors can be addressed without losing context.

```assembly
Nested_Exception_Handler:
    STMFD   SP!, {R0-R12, LR}       ; Save registers
    MRS     R0, SPSR                ; Save SPSR
    STMFD   SP!, {R0}

    ; Handle the first exception

    LDMFD   SP!, {R0}               ; Restore SPSR
    MSR     SPSR_cxsf, R0
    LDMFD   SP!, {R0-R12, PC}^      ; Restore registers and return
```

##### Deferred Exception Handling

In some cases, it may be beneficial to defer non-critical exception handling to a later time when the system is less busy. This can be achieved using a deferred procedure call (DPC) mechanism.

```assembly
Deferred_Exception_Handler:
    STMFD   SP!, {R0-R12, LR}       ; Save registers
    MRS     R0, SPSR                ; Save SPSR
    STMFD   SP!, {R0}

    ; Queue the deferred procedure call

    LDMFD   SP!, {R0}               ; Restore SPSR
    MSR     SPSR_cxsf, R0
    LDMFD   SP!, {R0-R12, PC}^      ; Restore registers and return

Deferred_Procedure_Call:
    ; Perform the deferred exception handling
    BX      LR                      ; Return from the DPC
```
