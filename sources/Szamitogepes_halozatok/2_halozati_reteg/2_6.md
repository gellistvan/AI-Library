6. Dinamikus routing protokollok

A számítógépes hálózatokban a routing, vagyis az útválasztás, elengedhetetlen a hatékony és megbízható adatforgalom biztosításához. Az útvonalválasztás két fő módja közül az egyik a statikus routing, ahol a hálózati adminisztrátor manuálisan állítja be az útvonalakat. A másik, és egyben rugalmasabb megoldás a dinamikus routing, amely során a hálózati eszközök, például az útválasztók, automatikusan tanulják meg és osztják meg az útvonalakat, adaptálódva a hálózat változásaihoz. Ebben a fejezetben a dinamikus routing protokollokat fogjuk vizsgálni, melyek két fő kategóriába sorolhatók: az IGP-k (Interior Gateway Protocols), amelyek az autonóm rendszereken belüli útválasztást kezelik, és az EGP-k (Exterior Gateway Protocols), amelyek az autonóm rendszerek közötti útválasztásért felelnek. Az IGP-k közé tartozik a jól ismert RIP (Routing Information Protocol), az OSPF (Open Shortest Path First) és az EIGRP (Enhanced Interior Gateway Routing Protocol). Az EGP-k közül kiemeljük a világ legelterjedtebb útválasztási protokollját, a BGP-t (Border Gateway Protocol). Ezen protokollok megértése alapvető fontosságú a modern hálózatok dinamikus és hatékony működésének biztosításához.

### 6. Dinamikus routing protokollok

#### IGP-k (Interior Gateway Protocols)

Az Interior Gateway Protocols (IGP-k) keretén belül számos standardot és algoritmust alkalmazunk, hogy az autonóm rendszeren (AS) belüli routing információkat dinamikusan kezeljük és optimalizáljuk. Az IGP-k feladata, hogy biztosítsák a hálózat belső útvonalainak hatékony szétosztását és fenntartását. Az IGP-k általában kisebb méretű, egységes adminisztráció alatt álló hálózatokban kerülnek alkalmazásra, mivel ezeknél hatékonyabbá teszik az útvonalválasztási információ terjesztését és az optimális útvonalak kiszámítását. Az IGP-k között a legnépszerűbbek közé tartozik a RIP (Routing Information Protocol), az OSPF (Open Shortest Path First), és az EIGRP (Enhanced Interior Gateway Routing Protocol).

**Routing Information Protocol (RIP)**: A RIP egy olyan distance-vector routing protokoll, amely az útvonalak optimalizálására a "hop count" metrikát (mennyit kell ugrani a csomópontig) használja. A protokoll alapértelmezett beállítás szerint 30 másodpercenként frissíti az útvonal információkat és 15 hopra korlátozza az útvonalak hosszát. A RIP alapvetően három fő változatban létezik: RIP version 1 (RIPv1), RIP version 2 (RIPv2) és RIPng (RIP next generation, IPv6 támogatáshoz).

A példakódban nézzük meg egy egyszerű RIP üzenet létrehozását C++ nyelven:

```cpp
#include <iostream>
#include <vector>
#include <cstring>

struct RIPEntry {
    uint16_t address_family;
    uint16_t route_tag;
    uint32_t ip_address;
    uint32_t subnet_mask;
    uint32_t next_hop;
    uint32_t metric;
};

struct RIPPacket {
    uint8_t command;
    uint8_t version;
    uint16_t zero;
    std::vector<RIPEntry> entries;

    void addEntry(const RIPEntry& entry) {
        entries.push_back(entry);
    }
};

void createRIPPacket(RIPPacket& ripPacket) {
    ripPacket.command = 2; // Response
    ripPacket.version = 2; // RIP version 2
    ripPacket.zero = 0;

    RIPEntry entry;

    entry.address_family = htons(2); // IP
    entry.route_tag = 0;
    entry.ip_address = htonl((192 << 24) | (168 << 16) | (1 << 8) | 0); // 192.168.1.0
    entry.subnet_mask = htonl(0xFFFFFF00); // 255.255.255.0
    entry.next_hop = 0;
    entry.metric = htonl(1); // Metric

    ripPacket.addEntry(entry);
}

int main() {
    RIPPacket ripPacket;
    createRIPPacket(ripPacket);

    std::cout << "RIP Packet Created with " << ripPacket.entries.size() << " entries." << std::endl;

    return 0;
}
```

**Open Shortest Path First (OSPF)**: Az OSPF egy link-state routing protokoll, amelyet az Internet Engineering Task Force (IETF) fejlesztett ki. Az OSPF igénye a link-state adatbázis (LSDB) létrehozásában áll, amely az adott hálózati topológia egy teljes' térképét' tartalmazza. Ezen adatbázis alapján Dijkstra algoritmusával számítja ki az optimális útvonalakat a különböző célállomásokhoz. Az OSPF számos központi tulajdonsággal bír, mint pl. a támogatás több területre bontott hálózatokhoz, route summary és route authentication.

A példakódban nézzük meg egy egyszerű OSPF Hello üzenet létrehozását C++ nyelven:

```cpp
#include <iostream>
#include <cstdint>
#include <vector>
#include <cstring>

struct OSPFHelloPacket {
    uint8_t version;
    uint8_t type;
    uint16_t packet_length;
    uint32_t router_id;
    uint32_t area_id;
    uint16_t checksum;
    uint16_t authentication_type;
    std::vector<uint32_t> neighbors;

    OSPFHelloPacket() {
        version = 2; // OSPFv2
        type = 1; // Hello packet
        packet_length = 0; // Will be updated after packet construction
        router_id = 0x01010101; // Example Router ID
        area_id = 0x00000000; // Example Area ID
        checksum = 0; // To be calculated
        authentication_type = 0; // No authentication
    }

    void addNeighbor(uint32_t neighbor_ip) {
        neighbors.push_back(neighbor_ip);
    }
};

uint16_t calculateChecksum(void* buf, size_t len) {
    uint16_t* data = reinterpret_cast<uint16_t*>(buf);
    uint32_t sum = 0;
    for (size_t i = 0; i < len / 2; ++i) {
        sum += data[i];
        if (sum & 0x80000000) {
            sum = (sum & 0xFFFF) + (sum >> 16);
        }
    }
    while (sum >> 16) {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }
    return ~sum;
}

void createOSPFHelloPacket(OSPFHelloPacket& helloPacket) {
    helloPacket.addNeighbor(0x02020202); // Example Neighbor ID

    // Packet length is header (24 bytes) + number of neighbors * 4 bytes
    helloPacket.packet_length = 24 + helloPacket.neighbors.size() * 4;

    // Calculate the checksum
    helloPacket.checksum = calculateChecksum(&helloPacket, helloPacket.packet_length);
}

int main() {
    OSPFHelloPacket helloPacket;
    createOSPFHelloPacket(helloPacket);

    std::cout << "OSPF Hello Packet Created with " << helloPacket.neighbors.size() << " neighbors." << std::endl;

    return 0;
}
```

**Enhanced Interior Gateway Routing Protocol (EIGRP)**: Az EIGRP a Cisco által kifejlesztett jellegzetes routing protokoll, amely hibrid routing metodológiát alkalmaz, ötvözve a distance-vector és a link-state tulajdonságokat. Az EIGRP ismeri a mellett az ad-hoc hálózatok gyors növekedéséhez szükséges szolgáltatásokat, mint pl. a VLSM (Variable Length Subnet Masking) és az MD5 aláírással ellátott hitelesítések támogatása. Az EIGRP az optimális útvonalakat a Diffusing Update Algorithm (DUAL) felhasználásával számítja ki.

A példakódban létrehozhatunk egy egyszerű EIGRP szomszédság-értesítési csomagot C++ nyelven:

```cpp
#include <iostream>
#include <cstdint>
#include <cstring>

struct EIGRPPacket {
    uint8_t version;
    uint8_t opcode;
    uint16_t checksum;
    uint32_t flags;
    uint32_t sequence;
    uint32_t ack_number;
    uint16_t AS_number;
    uint16_t EIGRP_packet_length;
    uint8_t payload[0];

    EIGRPPacket() {
        version = 2; // EIGRP version
        opcode = 5; // Hello packet
        checksum = 0; // To be calculated
        flags = 0;
        sequence = 0; // Incremental
        ack_number = 0;
        AS_number = 100; // Example AS number
        EIGRP_packet_length = 12; // Basic header length
    }    
};

uint16_t calculateEIGRPChecksum(void* buf, size_t len) {
    uint16_t* data = reinterpret_cast<uint16_t*>(buf);
    uint32_t sum = 0;
    for (size_t i = 0; i < len / 2; ++i) {
        sum += data[i];
    }
    return ~sum;
}

void createEIGRPHelloPacket(EIGRPPacket& eigrpPacket) {
    eigrpPacket.checksum = calculateEIGRPChecksum(&eigrpPacket, eigrpPacket.EIGRP_packet_length);
}

int main() {
    EIGRPPacket eigrpPacket;
    createEIGRPHelloPacket(eigrpPacket);

    std::cout << "EIGRP Hello Packet Created." << std::endl;
    
    return 0;
}
```

A fentiek alapján látható, hogy különböző IGP-k különböző módszerekkel és algoritmusokkal dolgoznak, hogy biztosítsák a hálózatok hatékony útvonalkezelését. Ez a rugalmasság és sokoldalúság teszi őket kulcsfontosságúvá a modern hálózati tervezésben és karbantartásban.

### RIP (Routing Information Protocol)

A Routing Information Protocol (RIP) egy széles körben elterjedt, viszonylag egyszerű belső átjáró protokoll (IGP), amelyet kisebb, egy autonóm rendszeren (AS) belüli hálózatokon használnak. A RIP a távolságvektor-algoritmuson alapul, és az IP hálózatban a hop számot használja a legjobb útvonalak meghatározására. A hálózati réteg szempontjából a RIP egyike a legrégebbi dinamikus routing protokolloknak, és annak ellenére, hogy újabb, kifinomultabb protokollok is léteznek, a RIP még mindig fontos része a hálózati oktatási anyagoknak és bizonyos korlátozott környezetekben használatban maradt.

#### RIP alapfogalmak és működés

A RIP működése a következő alapelveken alapul:
1. **Maximális Hop Szám**: A RIP 15 hopot engedélyez maximumnak egy útvonalon. Ha egy célállomás 16 vagy több hop távolságra van, az elérhetetlennek minősül.
2. **Frissítési Időközök**: A RIP interfészek 30 másodpercenként küldenek routing információkat, vagy "routing frissítéseket" minden szomszédos routerüknek.
3. **Útvonalfrissítések**: Minden router periodikusan küldi a komplett routing tábla másolatát a közvetlen szomszédainak (hust and broadcast alapon).
4. **Metrika**: A hop száma az, ami a távolság metrikáját képezi. Minden egyes hop növeli a metrikát eggyel.
5. **Méreg-inverzió és Split Horizon**: A holtponton elkerülésére a RIP méreg-inverziót és split horizon technikákat használ, melyek meggátolják a hurok képződést és a nem optimális utak elterjedését.

#### RIP Üzenetformátum

Minden RIP üzenet az UDP protokoll felett fut, tipikusan az 520-as portot használva. Az üzenetek formátuma a következő:

- **Command (1 byte)**: Meghatározza a történést; lehet Request vagy Response.
- **Version (1 byte)**: A RIP verziója (1 vagy 2).
- **Zero (2 byte)**: Nullára állított mező a kompatibilitás érdekében.
- **Routing Entries (mátrix)**: Tartalmazza a hálózati iránytávokat, mindegyik bejegyzés 20 byte méretű és tartalmazza az alábbiakat:
  - **Address Family Identifier (2 byte)**: Azonosítja a hálózati protokoll számát.
  - **IP Address (4 byte)**: Az útvonal IP címe.
  - **Subnet Mask (4 byte, csak RIP2 esetén)**: Az adott útvonal hálózati maszkja.
  - **Next Hop (4 byte, csak RIP2 esetén)**: A következő ugrás IP címe.
  - **Metric (4 byte)**: Az útvonal metrikája.

#### RIP Konfiguráció és Példakód C++-ban

A következőkben bemutatok egy egyszerű C++ példát, amely a RIP protokoll működését szemlélteti. 

##### C++ Kódrészlet: RIP Üzenet Építése és Paraszcsolási Példák

Az alábbi C++ kód egy egyszerű módját mutatja be a RIP üzenetek létrehozásának és elemzésének:

```cpp
#include <iostream>
#include <vector>
#include <cstring>
#include <arpa/inet.h>

// Definiáljuk a RIP üzenet struktúráját
struct RipEntry {
    uint16_t family;
    uint16_t routeTag;
    uint32_t ipAddress;
    uint32_t subnetMask;
    uint32_t nextHop;
    uint32_t metric;
};

struct RipPacket {
    uint8_t command;
    uint8_t version;
    uint16_t zero;
    std::vector<RipEntry> entries;
};

// Funkció RIP üzenet építésére
RipPacket createRipResponse(const std::vector<RipEntry>& entries) {
    RipPacket packet;
    packet.command = 2; // Response
    packet.version = 2; // RIP version 2
    packet.zero = 0;
    packet.entries = entries;
    return packet;
}

// Funkció RIP üzenet nyomtatására
void printRipPacket(const RipPacket& packet) {
    std::cout << "Command: " << static_cast<int>(packet.command) << std::endl;
    std::cout << "Version: " << static_cast<int>(packet.version) << std::endl;
    std::cout << "Zero field: " << packet.zero << std::endl;
    for (const auto& entry : packet.entries) {
        struct in_addr ipAddr;
        ipAddr.s_addr = entry.ipAddress;
        std::cout << "IP Address: " << inet_ntoa(ipAddr) << std::endl;
        ipAddr.s_addr = entry.subnetMask;
        std::cout << "Subnet Mask: " << inet_ntoa(ipAddr) << std::endl;
        ipAddr.s_addr = entry.nextHop;
        std::cout << "Next Hop: " << inet_ntoa(ipAddr) << std::endl;
        std::cout << "Metric: " << ntohl(entry.metric) << std::endl;
    }
}

int main() {
    // Példa úti jegyzők építése
    std::vector<RipEntry> entries;
    RipEntry entry1 = { htons(2), 0, inet_addr("192.168.1.0"), inet_addr("255.255.255.0"), inet_addr("0.0.0.0"), htonl(1) };
    entries.push_back(entry1);
    
    // RIP packet készítése és nyomtatása
    RipPacket packet = createRipResponse(entries);
    printRipPacket(packet);
    
    return 0;
}
```

#### További Fontos Részletek és Eljárások

1. **Útkeresés és Frissítések**: Amikor egy router fogad egy RIP üzenetet, frissíti a routing tábláját, ha a kapott információk jobb (azaz kisebb hop számú) útvonalat jelentenek valamilyen célállomás felé.
2. **Holtpont Kezelés**: A méreg-inverzió és split horizon működési mechanizmusok használatával a RIP optimalizálja a hálózat forgalmát és minimalizálja a holtpont kockázatát.
3. **Időzítő Mechanizmusok**: A RIP többféle időzítőt használ az adatcsere és holtpont felderítés érdekében:
   - **Update Timer**: Beállítja az időintervallumot, amely után periódikusan frissítést küldenek (általában 30 másodperc).
   - **Invalid Timer**: Ha egy adott idő alatt (180 másodperc) nem kap frissítést egy adott útvonalhoz, akkor az útvonal érvénytelennek tekintendő.
   - **Flush Timer**: Az érvénytelennek tekintett útvonalakat egy bizonyos idő után (240 másodperc) eltávolítják a routing táblából.

#### Zárógondolat

A RIP, annak egyszerűsége és hosz szám korlátai miatt, inkább kisebb hálózatokban használatos. Előnye annak egyszerű beállításában és minimálisan szükséges erőforrásigényében rejlik. Azonban nagyobb és összetettebb hálózatok esetében már jelentősebb protokollokra, mint például az OSPF vagy EIGRP szükséges átállni.

A következő fejezetekben a modernebb és bonyolultabb routing protokollok bemutatásával folytatjuk, mint az OSPF és EIGRP, melyek jelentősen nagyobb rugalmasságot és méretezhetőséget biztosítanak nagy hálózatok számára.

### 6.4 OSPF (Open Shortest Path First)

Az OSPF (Open Shortest Path First) egy link-state routing protokoll, amelyet széles körben használnak az autonóm rendszerek belső hálózatainak (Interior Gateway Protocol, IGP) irányítására. Az OSPF alapvető célja, hogy a hálózati csomópontok közötti adatforgalom útvonalát optimalizálja a legkisebb költségű út kiválasztásával, így javítva a hálózat hatékonyságát és csökkentve a késleltetést. Ez a fejezet részletesen tárgyalja az OSPF protokoll működését, főbb jellemzőit, valamint néhány gyakorlati példát is bemutat.

#### 6.4.1 OSPF Alapjai

Az OSPF egy link-state protokoll, amely a rövid legrövidebb útnak (Shortest Path First, SPF) algoritmust használja az útvonalak kiszámítására. Az OSPF hálózatok routerei kijelölt (designated router, DR) és helyettesített (backup designated router, BDR) routereket választanak, hogy csökkentsék az üzenetküldési költségeket.

##### 6.4.1.1 Link-State Advertisements (LSA)

Az OSPF routerek egymás között link-state advertisement (LSA) üzeneteket cserélnek, amelyek információkat tartalmaznak a routerek és azok összeköttetéseinek állapotáról. Az LSA-k segítségével minden router felépíti saját látképét a hálózatról, majd ezek alapján számítja ki az optimális útvonalakat. Az OSPF támogatja többféle LSA típust, például:

- **Router-LSA:** Információkat tartalmaz a router interfészeiről, valamint azok állapotáról és költségéről.
- **Network-LSA:** A DR küldi és tartalmazza az adott hálózaton elérhető routerek listáját.
- **Summary-LSA:** Az Autonomous System Border Router (ASBR) és az Area Border Router (ABR) így terjeszti a hálózat többi részéhez tartozó információkat.

##### 6.4.1.2 Hello Protocol

Az OSPF routerek a Hello protokoll segítségével tartják fenn a kapcsolatot egymással. A Hello üzenetek tartalmazzák a csomópontok azonosítóját, valamint a kapcsolat élettartamát. A Hello üzenetek célja, hogy azonosítsák a szomszédos routereket és felderítsék az elérhetőséget. Ha egy router túl hosszú ideig (Dead Interval) nem kap Hello üzenetet egy szomszédjától, azt a szomszédot elérhetetlennek tekinti.

#### 6.4.2 OSPF Adattervezés

Az OSPF támogatja a hierarchikus hálózati struktúrákat, amelyeket az Area (terület) fogalmán keresztül valósít meg. Egy OSPF terület egy logikai szegmens, amelyen belül a routerek ismerik egymás minden részletét. A legfelsőbb szint az Area 0, vagy Backbone Area, amely összeköti a többi területet.

- **Backbone Area (Area 0):** Ez az OSPF hálózat gerince, amely összeköti a különböző területeket.
- **Non-Backbone Areas:** Ezek további területek, amelyek Area Border Routereken (ABR) keresztül csatlakoznak az Area 0-hoz.

Az OSPF területi hierarchiája lehetővé teszi a hálózati forgalom és a routing információk optimalizálását, csökkentve ezzel az összterhelést és a hálózati konvergencia időt.

#### 6.4.3 OSPF Algoritmus

Az OSPF az SPF algoritmust alkalmazza, amelyet általában Dijkstra algoritmusnak is neveznek. Ez az algoritmus a routerek között a link-state adatstruktúrákat felhasználva keresi meg a legrövidebb utat. Az SPF fa létrehozása érdekében a következő lépéseket követi:

1. **Initializáció:** A router egy listában csak saját magát tartalmazza.
2. **Iteráció:** Kiválasztja a listában a legkisebb költséggel rendelkező csomópontot, majd az ahhoz csatlakozó csomópontokat hozzáadja a listához.
3. **Frissítés:** Az algoritmus frissíti minden csomópont költségét a router felé addig, amíg az összes végpontot ki nem választja.

A következő C++ példa egy egyszerű megvalósítást mutat az SPF algoritmusra:

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <limits>
#include <unordered_map>

using namespace std;

class OSPFRouter {
public:
    void addEdge(int u, int v, int weight);
    void shortestPath(int src);

private:
    unordered_map<int, vector<pair<int, int>>> adjList;
};

void OSPFRouter::addEdge(int u, int v, int weight) {
    adjList[u].push_back(make_pair(v, weight));
    adjList[v].push_back(make_pair(u, weight));
}

void OSPFRouter::shortestPath(int src) {
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
    unordered_map<int, int> dist;

    for (const auto& pair : adjList) {
        dist[pair.first] = numeric_limits<int>::max();
    }
    pq.push(make_pair(0, src));
    dist[src] = 0;

    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();

        for (const auto& neighbor : adjList[u]) {
            int v = neighbor.first;
            int weight = neighbor.second;

            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push(make_pair(dist[v], v));
            }
        }
    }

    for (const auto& pair : dist) {
        cout << "Distance from node " << src << " to node " << pair.first << " is " << pair.second << endl;
    }
}

int main() {
    OSPFRouter router;
    router.addEdge(1, 2, 4);
    router.addEdge(1, 3, 2);
    router.addEdge(2, 3, 1);
    router.addEdge(2, 4, 5);
    router.addEdge(3, 4, 8);
    router.addEdge(3, 5, 10);
    router.addEdge(4, 5, 2);

    router.shortestPath(1);

    return 0;
}
```

Ez a C++ kód bemutat egy egyszerű OSPF routert, amely képes a legrövidebb útvonalak számítására. Az `addEdge` metódus egy új élt ad hozzá a hálózathoz, a `shortestPath` metódus pedig kiszámítja és kiírja a legkisebb költségű útvonalakat a kiinduló csomópontról.

#### 6.4.4 OSPF Konfiguráció

Az OSPF konfiguráció különböző szintű beállításokat igényel, a routerek beállításától kezdve a területek felosztásáig. Az alábbi példa egy általános OSPF konfigurációs példa Cisco routerek esetén:

```plaintext
Router(config)# router ospf 1
Router(config-router)# network 192.168.1.0 0.0.0.255 area 0
Router(config-router)# network 192.168.2.0 0.0.0.255 area 0
Router(config-router)# network 192.168.3.0 0.0.0.255 area 1
Router(config-router)# area 1 stub
Router(config-router)# exit
Router(config)#
```

Ez a konfiguráció három alhálózatot definiál: két alhálózat az Area 0-ba tartozik, míg a harmadik az Area 1-be. Az Area 1 stub területként van konfigurálva, amely csökkenti az OSPF LSDB (Link-State Database) méretét és a routing információkat ezen a területen. Az OSPF területek és alhálózatok megfelelő elrendezése különösen fontos a nagy, bonyolult hálózatok esetén, mivel ezzel optimalizálható az adatforgalom és csökkenthető a hálózati terhelés.

#### 6.4.5 OSPF Biztosítások és Hibakeresés

Az OSPF protokoll bizonyos biztosításokat kínál a hibák elkerülésére és a megbízhatóság növelésére. Ezek:

- **MD5 Authentication:** Hitelesítés az MD5 algoritmussal, amely biztosítja, hogy csak valid routerek vehetnek részt az adatcsere folyamatában.
- **Cost Metrics:** Az útvonal költségmérői dinamikusan állíthatók, amelyek lehetővé teszik a preferált utak kiválasztását a hálózaton belül.
- **Dead Interval és Hello Timer:** A Cisco routereknél ezek az intervallumok konfigurálhatók, hogy optimalizálják a kapcsolat felderítési és élettartam beállításokat.

A következő egy példa az MD5 authentikáció konfigurálására:

```plaintext
Router(config)# interface gigabitethernet 0/0
Router(config-if)# ip ospf authentication message-digest
Router(config-if)# ip ospf message-digest-key 1 md5 MySecretKey
Router(config-if)# exit
```

Ezzel az OSPF MD5 hitelesítést konfigurálja a `0/0` interface-en, amely további védettséget nyújt a hitelesítetlen hozzáférések ellen.

#### 6.4.6 Összefoglalás

Az OSPF egy megbízható és hatékony routing protokoll, amely lehetővé teszi a dinamikus, optimális útvonal választást különböző hálózati topológiákban. Az OSPF hierarchikus tervezésével és a link-state adatcseréinek segítségével biztosítja a hálózati adatforgalom optimalizálását és a gyors konvergenciát. Az OSPF konfiguráció megfelelő beállítása és a hibakeresés során alkalmazott technikák kulcsfontosságúak a nagy és komplex hálózatok sikeres működtetése érdekében.

### 6. Dinamikus routing protokollok

#### - EIGRP (Enhanced Interior Gateway Routing Protocol)

Az EIGRP (Enhanced Interior Gateway Routing Protocol) egy Cisco által kifejlesztett, fejlett, hatékony és skálázható dinamikus routing protokoll, amelyet belső hálózatokban (IGP-ként) használnak. Az EIGRP a legtöbb esetben zárt forráskódú volt a Cisco rendszereiben, de 2013 óta néhány specifikációja már nyitott és más gyártók is használhatják.

##### EIGRP alapjai

Az EIGRP egy hibrid routing protokoll, mely ötvözi a távolságvektor és a link-state routing protokollok jellemzőit. Röviden összefoglalva:

1. **Távolságvektor alapú**: Az EIGRP alapvetően távolságvektor alapú, melyben az útvonalak költségeit (metric) a hop száma, a sávszélesség, a késleltetés, megbízhatóság és terhelés alapján számítja ki.
2. **Link-state szerű viselkedés**: Az EIGRP hasonlóan a link-state protokollokhoz részletes toplógiai információkat tart fenn, melyek segítségével gyorsabb konvergenciát ér el.
3. **DUAL algoritmus**: Az EIGRP a DUAL (Diffusing Update Algorithm) algoritmust használja, amely gyors konvergenciát és loop-mentes hálózatot biztosít.

##### EIGRP működése

Az EIGRP saját fejlett mechanizmusaival és üzenettípusaival működik. Az EIGRP működési folyamata az alábbi komponensekből áll:

1. **Hello Packet-ek**: Az EIGRP routerek rendszeresen hello packet-eket küldenek, hogy azonosítani tudják aktív szomszédaikat.
2. **Neighbor Discovery and Recovery**: A hello packet-ek fogadása után a routerek szomszédsági kapcsolatot létesítenek.
3. **Reliable Transport Protocol (RTP)**: Az RTP biztosítja a megbízható adatátvitelt az EIGRP routerek között.
4. **DUAL algoritmus**: A DUAL feladata az útvonalak kalkulációja és a hurokmentes hálózat biztosítása. A DUAL az útvonalakat két állapotba helyezi: potential successor és successor.

##### EIGRP Packet típusok

Az EIGRP különböző típusú üzeneteket használ a működéséhez:

1. **Hello Packet**: Az állapotok felfedezéséhez és a szomszédsági állapotok fenntartásához használatos.
2. **Update Packet**: Frissítéseket küld a szomszédos routerek számára, ahogy az útvonalak változnak.
3. **Query Packet**: Kérdéseket küld az alternatív útvonalak keresésére.
4. **Reply Packet**: Válaszol a Query Packet-ekre az alternatív útvonalak információival.
5. **ACK Packet**: Az Update és Query Packet-ek megerősítésére szolgál.

##### Metric Számítása

Az EIGRP métrikája több tényezőből tevődik össze: sávszélesség, késleltetés, megbízhatóság és terhelés. Az alapértelmezett métrika a sávszélesség és a késleltetés alapján számítódik ki az alábbi képlettel:

$$ \text{Metric} = \left( \frac{10^7}{\text{min. sávszélesség}} \right) + \text{késleltetés} $$

Ahol a sávszélesség 10^7-es értékkel van normálva és a késleltetés a vonal késleltetés értéke mikroszekundumban. Az EIGRP metric különböző kiváló jellemzői segítenek a legjobb útvonal kijelölésében és a forgalomirányítás optimalizálásában.

##### Példa egy EIGRP konfigurációra Cisco routeren

```C++
R1(config)# router eigrp 1
R1(config-router)# network 192.168.1.0 0.0.0.255
R1(config-router)# no auto-summary
R1(config-router)# end
```

Ez a konfiguráció egy EIGRP processz indítását mutatja meg egy Cisco routeren:

1. A `router eigrp 1` parancs elindít egy EIGRP processzt autonóm rendszer (AS) azonosítóval 1.
2. A `network 192.168.1.0 0.0.0.255` parancs az EIGRP-t alkalmazza a 192.168.1.0/24 hálózaton.
3. A `no auto-summary` parancs letiltja az automatikus hálózati összegzést.

##### EIGRP Adatstruktúrák és Implementáció C++-ban

A következőkben egy egyszerű EIGRP adatstruktúrát és néhány alapvető funkcióját mutatjuk be C++-ban:

```C++
#include <iostream>
#include <vector>
#include <map>
#include <limits>

#define MAX_BANDWIDTH 10000000

class EIGRPRoute {
public:
    std::string destination;
    int bandwidth;
    int delay;

    EIGRPRoute(std::string dest, int bw, int d) : destination(dest), bandwidth(bw), delay(d) {}
    
    int calculateMetric() {
        return (MAX_BANDWIDTH / bandwidth) + delay;
    }
};

class EIGRPNode {
    std::map<std::string, EIGRPRoute> routingTable;

public:
    void addRoute(std::string dest, int bw, int d) {
        EIGRPRoute route(dest, bw, d);
        routingTable[dest] = route;
    }

    void displayRoutes() {
        for (const auto& entry : routingTable) {
            std::cout << "Destination: " << entry.second.destination
                      << ", Metric: " << entry.second.calculateMetric() << std::endl;
        }
    }
};

int main() {
    EIGRPNode node;
    node.addRoute("192.168.1.0", 1000, 10);
    node.addRoute("192.168.2.0", 2000, 20);
    
    node.displayRoutes();
    return 0;
}
```

#### Magyarázat

1. **EIGRPRoute Osztály**: Az EIGRPRoute osztály reprezentál egy EIGRP routing bejegyzést. A `calculateMetric` metódus kiszámítja a routing metrikát.
2. **EIGRPNode Osztály**: Az EIGRPNode osztály kezeli a router routing tábláját. Az `addRoute` metódus hozzáad egy útvonalat, míg a `displayRoutes` metódus megjeleníti az összes útvonalat és azok metrikáját.
3. **Main függvény**: A `main` függvényben két útvonalat adunk hozzá a routing táblához és megjelenítjük őket.

##### Konklúzió

Az EIGRP egy fejlett dinamikus routing protokoll, mely gyors konvergenciával, hatékony métrika kalkulációval és megbízható adatátviteli mechanizmusokkal rendelkezik. Bár eredetileg Cisco-specifikus volt, jelenlegi nyitott specifikációinak köszönhetően más gyártók is implementálhatják és használhatják. Az EIGRP implementációk és konfigurációk megértése és kezelése elengedhetetlen a hálózati szakemberek számára a belső hálózatok hatékony irányításához és optimalizálásához.

### 6. Dinamikus routing protokollok

#### - EGP-k (Exterior Gateway Protocols)

Az Exterior Gateway Protocols (EGP-k) olyan routing protokollok, amelyek célja, hogy különböző autonóm rendszerek (Autonomous Systems, AS-ek) között biztosítsák az útvonaltájékoztatást. Az autonóm rendszerek egy-egy, gyakran egyetlen adminisztrációs szervezet által irányított hálózati területek, amelyek saját belső routing protokolljaikat (Interior Gateway Protocols, IGP-k) használják. Az EGP-k viszont az AS-ek közötti útvonalak meghatározásáért felelősek, biztosítva ezzel a globális internet forgalmának hatékony kezelését.

**Fontosabb EGP protokollok**

Míg a belső hálózatokban számos IGP protokoll létezik, az EGP protokollok közül leginkább a Border Gateway Protocol (BGP) ismert és elterjedt. Ugyanakkor fontos megjegyezni, hogy a korai internetes időkben létezett egy protokoll, amit egyszerűen Exterior Gateway Protocol (EGP) néven ismertek, ami mára már elavult.

**Exterior Gateway Protocol (EGP)**

Az EGP volt az első jelentős EGP protokoll, amelyet az ARPANET és az NSFNET korai napjaiban használtak. Az EGP azonban számos korlátozással bír, amelyek miatt nem volt alkalmas a modern interneten való használatra.

Az EGP működése rendkívül egyszerű volt, és nem biztosított útvonalválasztási metrikákat az optimális útvonalak meghatározásához. Ehelyett alapvetően csak egyszerű elérhetőségi információkat közvetített az AS-ek között. Az EGP használatának egyik jelentős korlátozása az volt, hogy fa-struktúrában kellett rendezni az AS-eket, amely nem felelt meg a hálózati topológia valóságos bonyolultságának.

**Border Gateway Protocol (BGP)**

A BGP az EGP utódja, amely számos kulcsfontosságú fejlesztést tartalmaz az előző protokollhoz képest. A BGP-t úgy tervezték, hogy a mai nagy, bonyolult autonóm rendszerek igényeit kielégítse. Mivel az internet egy hatalmas, dinamikusan változó hálózat, olyan protokollra van szükségünk, amely képes kezelni a gyakori útvonalváltozásokat és a forgalmi terheléseket.

A BGP egy útvonalválasztási protokoll, amelyet az AS-ek közötti routing információk cseréjére használnak. A BGP-4, amely a BGP legutóbbi verziója, egy path vector protokoll, ami az útvonalak rögzítésére és hirdetésére szolgáló útvonalvektorokat használja.

**BGP működése**

A BGP működésének megértéséhez alapvetően két fő komponenst kell megvizsgálni: az útvonal választást és az útvonalak hirdetését.

- **Útválasztás**: A BGP az Autonomous Systems Path (AS Path) vektort használja az útvonalak meghatározásához. Az AS Path minden egyes AS-t tartalmaz, amelyen egy adott útvonal keresztül halad. Mivel a BGP nem használ metrikát, mint számos IGP, inkább az AS Path hossza alapján dönt Route választáskor. A rövidebb AS Path-ú útvonalakat előnyben részesítik.

- **Útvonalak hirdetése**: A BGP az úgynevezett "Update" üzeneteket használja az útvonalak hirdetésére. Egy Update üzenet tartalmazhat új útvonalakat, valamint visszavonási (withdraw) információkat is korábbi útvonalakra vonatkozóan. Az Update üzenetek hierarchikus üzenetek, amelyek a változó hálózati topológia alapján frissítik a routing táblákat.

BGP-vel kapcsolatos fontos fogalmak:

1. **BGP Peers**: A BGP-t használó szomszédos routerek (BGP Peers) BGP Session-ön keresztül kommunikálnak egymással.

2. **Route Reflectors & Confederations**: Ezek a technikák lehetővé teszik a nagyobb hálózatok méretezhetőségét, és csökkentik a szükséges BGP session-ök számát.

**BGP Példa kód C++-ban**

A BGP implementációja bonyolult és számos specifikus részletet tartalmaz, azonban egy egyszerűsített példa, amely a BGP 'KEEPALIVE' üzenetet mutatja be, hasznos lehet a jobb megértéshez.

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define BGP_PORT 179
#define KEEPALIVE_MSG "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x00\x13\x04"

class BGPClient {
public:
    BGPClient(const char* peer_ip) {
        peerAddress.sin_family = AF_INET;
        peerAddress.sin_port = htons(BGP_PORT);
        inet_pton(AF_INET, peer_ip, &peerAddress.sin_addr);
    }
    
    bool connectToPeer() {
        sock = socket(AF_INET, SOCK_STREAM, 0);
        if (sock < 0) {
            perror("Socket creation failed");
            return false;
        }

        if (connect(sock, (struct sockaddr*)&peerAddress, sizeof(peerAddress)) < 0) {
            perror("Connection to peer failed");
            return false;
        }
        std::cout << "Connected to BGP peer successfully.\n";
        return true;
    }
    
    void sendKeepAlive() {
        if (send(sock, KEEPALIVE_MSG, strlen(KEEPALIVE_MSG), 0) < 0) {
            perror("Sending KEEPALIVE message failed");
        } else {
            std::cout << "KEEPALIVE message sent successfully.\n";
        }
    }

    ~BGPClient() {
        if (sock >= 0) close(sock);
    }

private:
    int sock;
    struct sockaddr_in peerAddress;
};

int main() {
    BGPClient bgpClient("192.0.2.1");
    
    if (bgpClient.connectToPeer()) {
        while (true) {
            bgpClient.sendKeepAlive();
            sleep(60); // Keep-alive messages typically sent every 60 seconds.
        }
    }
    
    return 0;
}
```

Ez a példa egy rendkívül egyszerű keepalive üzenet küldését valósítja meg egy BGP kapcsolat alatt. Természetesen a valós world BGP implementációja sokkal bonyolultabb, és nemcsak a keepalive üzeneteket tartalmazza, hanem számos más üzenettípust is, mint az 'OPEN', 'UPDATE', és 'NOTIFICATION', valamint az útvonal választási algoritmusokat.

**Konklúzió**

Az Exterior Gateway Protocols, különösen a BGP, alapvető szerepet játszanak az internet globális architektúrájában. Ahogy az autonóm rendszerek közötti routing igények növekednek, úgy a BGP és hasonló protokollok továbbfejlesztésére és finomítására egyre nagyobb szükség lesz. Az ilyen protokollok ismerete és megértése kulcsfontosságú minden hálózati szakember számára, aki a mai hálózati rendszereket tervezi és karbantartja.

### BGP (Border Gateway Protocol)

A Border Gateway Protocol (BGP) egy dinamikus routing protokoll, amelyet az autonóm rendszerek (Autonomous Systems, AS) közötti útvonalak terjesztésére és kezelési információk terjesztésére használnak az interneten. A BGP egy rendkívül skálázható és nagy konfigurálhatósággal rendelkező protokoll, amely lehetővé teszi a hálózati adminisztrátorok számára, hogy kifinomult útvonalválasztási döntéseket hozzanak. A BGP az Exterior Gateway Protocolok (EGP) kategóriájába tartozik, és meghatározó szerepet játszik az internet infrastruktúrájában.

#### BGP működése
A BGP fő feladata az útvonalak cseréje és fenntartása különböző autonóm rendszerek között. Az autonóm rendszer egy egységes irányítás alatt álló hálózatok összessége, amelyet egy egyedi autonóm rendszer számmal (ASN) azonosítanak. A BGP alapvetően a megbízhatóságra és stabilitásra összpontosít, és összetett útvonalválasztási stratégiákat támogat.

##### BGP Üzenettípusok
A BGP négyfajta üzenettípust használ az információk cseréjére:
1. **Open**: Ezt az üzenetet használják a BGP szomszédsági kapcsolatok kezdő beállításához.
2. **Update**: Ezen üzenetek segítségével hirdetik és visszavonják az útvonalakat.
3. **Notification**: Hibaüzeneteket tartalmaz, és a kapcsolat lezárására is használják.
4. **Keepalive**: Ezek az üzenetek biztosítják, hogy a kapcsolat aktív és fenntartott maradjon.

##### BGP Átviteli Mód
A BGP az útvonal választás során TCP protokollt (port 179) használ az üzenetek átviteléhez, amely megbízható adatátvitelt garantál. A TCP használata lehetővé teszi a BGP-nek, hogy megbízható, szekvenciális üzenetkézbesítést valósítson meg, amelyek kritikusak a pontos útvonalinformációk fenntartásához.

#### BGP Attribútumok
A BGP döntéshozási folyamatában számos útvonal-attribútum játszik szerepet, amelyeket az útvonalválasztási döntések során figyelembe vesznek. Ezek az attribútumok segítenek meghatározni a legjobb útvonalat a célhálózatba. Az alábbiakban néhány fontosabb attribútum kerül bemutatásra:

1. **AS_PATH**: Az autonóm rendszerek listája, amelyeket egy útvonal áthalad.
2. **NEXT_HOP**: A következő ugrás IP címe a cél felé vezető úton.
3. **ORIGIN**: Az útvonal eredete (IGP, EGP, vagy Incomplete).
4. **LOCAL_PREF**: Az útvonal preferenciájának helyi beállítása.
5. **MED (Multi-Exit Discriminator)**: Lehetőséget biztosít az eltérő útvonalak prioritásának meghatározásához.

#### BGP Állapotok
A BGP router öt különböző állapotot használ a BGP szomszédsági kapcsolatának létrehozása és fenntartása során:
1. **Idle**: Kezdő állapot, amikor a BGP folyamat még nincs aktív.
2. **Connect**: A TCP kapcsolat létrehozása folyamatban van.
3. **Active**: Próbálkozás új TCP kapcsolat létrehozására.
4. **OpenSent**: Open üzenet elküldve, várakozás az Open üzenetre a szomszédtól.
5. **OpenConfirm**: Várakozás a Keepalive vagy Notification üzenetre.
6. **Established**: A kapcsolat létrejött, és az útvonalinformációk cseréje folyamatban van.

#### Implementációs Példák

Az alábbiakban bemutatunk egy egyszerű BGP folyamatot, amely C++ nyelven valósítható meg. Ez a példa bemutatja, hogyan lehet a TCP kapcsolatokat kezelni, és hogyan lehet BGP üzeneteket küldeni és fogadni.

```cpp
#include <iostream>
#include <boost/asio.hpp>

using boost::asio::ip::tcp;

class BGP {
public:
    BGP(boost::asio::io_service& io_service, const std::string& host)
            : resolver_(io_service), socket_(io_service) {
        tcp::resolver::query query(host, "179");
        resolver_.async_resolve(query,
                                [this](const boost::system::error_code& err, tcp::resolver::iterator endpoint_iterator) {
                                    if (!err) {
                                        handle_resolve(err, endpoint_iterator);
                                    }
                                });
    }

protected:
    void handle_resolve(const boost::system::error_code& err, tcp::resolver::iterator endpoint_iterator) {
        if (!err) {
            tcp::endpoint endpoint = *endpoint_iterator;
            socket_.async_connect(endpoint,
                                  [this](const boost::system::error_code& err) {
                                      if (!err) {
                                          handle_connect(err);
                                      }
                                  });
        }
    }

    void handle_connect(const boost::system::error_code& err) {
        if (!err) {
            std::string open_message = create_open_message();
            boost::asio::async_write(socket_, boost::asio::buffer(open_message),
                                     [this](const boost::system::error_code& err, std::size_t) {
                                         if (!err) {
                                             read_response();
                                         }
                                     });
        }
    }

    void read_response() {
        boost::asio::async_read(socket_, boost::asio::buffer(reply_, 1024),
                                [this](const boost::system::error_code& err, std::size_t bytes_transferred) {
                                    if (!err) {
                                        std::cout << "BGP Response: " << std::string(reply_, bytes_transferred) << std::endl;
                                    }
                                });
    }

    std::string create_open_message() {
        char open_message[29] = {};
        open_message[0] = 0x04; // Version
        open_message[1] = 0x00; // My ASN (2 bytes)
        open_message[2] = 0xB4; // Hold Time (2 bytes)
        open_message[3] = 0xC0;
        open_message[4] = 0xA8;
        open_message[5] = 0x00;
        open_message[6] = 0x01; // BGP Identifier (4 bytes)
        
        return std::string(open_message, 29);
    }

private:
    tcp::resolver resolver_;
    tcp::socket socket_;
    char reply_[1024];
};

int main() {
    try {
        boost::asio::io_service io_service;
        BGP bgp(io_service, "127.0.0.1");
        io_service.run();
    } catch (std::exception& e) {
        std::cerr << "Exception: " << e.what() << std::endl;
    }
    return 0;
}
```

#### Részletes Magyarázat
A fenti kódban az első lépés a BGP kapcsolat felépítése a megadott IP címmel. A `BGP` osztály a boost::asio könyvtárat használja az aszinkron TCP kapcsolat kezelésére.

1. **Open Message**: A `create_open_message` metódus létrehozza a BGP Open üzenetet. Az üzenet tartalmazza a BGP verzióját, az ASN-t, a Hold időt és a BGP azonosítót.
2. **Async Handlers**: Az aszinkron írási és olvasási műveletek segítségével kezeljük a TCP kapcsolatot és az üzeneteket. A kapcsolat sikeres létrehozása után egy BGP Open üzenetet küldünk a peernek, majd a `read_response` metódussal várjuk a válaszokat.

Ez a nagyon egyszerű példa csupán egy BGP kapcsolat néhány alapvető mozzanatát mutatja be. A valós világban egy teljes BGP implementáció ennél jóval összetettebb, figyelembe veszi az összes BGP állapotot, üzenettípust és attribútumot. Az adminisztrátoroknak széleskörű konfigurációs lehetőségeik vannak, hogy irányítsák a forgalmat, elkerüljék a nem kívánt útvonalakat, és biztosítsák a hálózat stabil és hatékony működését.

